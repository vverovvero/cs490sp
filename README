Wendy Chen
CPSC 490 Spring 2017

---------------------------------------------------------------------
/************************* General Notes ***************************/
---------------------------------------------------------------------

This is the current unidirectional path tracer I have implemented as part of my study into path tracing theory.

Geometry obj files from:
http://people.sc.fsu.edu/~jburkardt/data/obj/obj.html

The source code for this project can be found at:
https://github.com/vverovvero/cs490sp/tree/master

Branches:
master 	(last stable release)
wip 	(developing next feature in LOG)

---------------------------------------------------------------------
/**************** Compiling and Rendering **************************/
---------------------------------------------------------------------

This path tracer was developed on MacOSX in C++.  The cairo image library needs to be installed.

If you are a Mac user, you can install cairo with the command:
brew install cairo

To compile on a different machine, you will need to have cairo correctly installed.

Using the provided makefile, simply type 'make' to generate an executable named 'main'.
To manually compile on MacOSX with clang++, the following can be entered on the command line:
clang++ -I/usr/local/include/cairo/ -L/usr/local/lib -o main main.cpp -lcairo

Currently, the scene and image output file name can be modified only manually within the source code.
Change the .h file that is loaded if you would like to change the scene file.
Change the output file name in the cairo png generation loop.

The output of this program is a .png that shows the rendered scene.

---------------------------------------------------------------------
/*********************** Scene files *******************************/
---------------------------------------------------------------------

This path tracer accepts scene information in a two-pass workflow.
The user specifies a text file (sce file), which is parsed into a binary.
The program accepts the binary and renders the scene.

.sce -> binary 	SCEparser.py
binary -> image  main.cpp

For more complicated geometry, the general workflow is:

.obj -> .txt 	OBJparser.py
.txt -> .sce 	TXTparser.py
.sce -> binary 		SCEparser.py
binary -> image		main.cpp

OBJparser.py:
python ./OBJparser.py <input_obj_file> <output_txt_file>

OBJparser.py will take an obj file and produce a vertex array and a face array.
We assume that these obj files have been exported from Maya.  They are assumed to have been pre-processed such that the object is at the world origin (0, 0, 0) and is aligned with the ground plane to be standing up.

TXTparser.py
python ./TXTparser.py <input_txt_file> <output_sce_file>

TXTparser takes a txt file of vertex and index array.  These txt files must be products of OBJparser.py.
TXTparser generates .sce files, where the mesh consists only of TRIANGLE primitives.
No material is associated with the mesh.

SCEparser.py
python ./SCEparser.py <input_sce_file> <output_binary_file>
SCEparser.py will produce a binary file that contains structs for triangles, spheres, lights, materials, objects...
For geometry, it can handle sphere and triangle primitives.
It also handles light primitives, material primitives, and object array primitive.

.sce file specification:
Initialize primitives such as:
CAMERA, LIGHT, MATERIAL, SPHERE, TRIANGLE, INCLUDE
Important: Material Indices begin at 0!  User must keep this in mind when specifying TRIANGLE or SPHERE primitives
Important: Any scene file must contain a camera
Important: INCLUDE cannot contain nested INCLUDEs
-INCLUDE only supports geometry (SPHERE, TRIANGLE)
-Transformations supported for SPHERE: Translate(x, y, z), ScaleR(s), RotateX(a), RotateY(a), RotateZ(a)
-Transformations supported for TRIANGLE: Translate(x, y, z), Scale(x, y, z), RotateX(a), RotateY(a), RotateZ(a)



---------------------------------------------------------------------
/*********************** Acceleration ******************************/
---------------------------------------------------------------------

A kd-tree acceleration structure will be implemented.

