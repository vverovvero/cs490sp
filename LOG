cd /Users/wendychen/Desktop/cs490_serial_raytracer/unidirectional_pathtracer

---------------------------------------------------------------------
/********************* Latest meeting *************************/
---------------------------------------------------------------------

2/14:
-inside of the .h file, the vertices can be stored in their own array and
referenced by index in the triangle structs


2/21:
-read in the geometry at run time instead
-send progress report for next week

3/8:
-Need to fix parsing.  Now it's spring break

3/28:
-fix the scene parsing (using an intermediate binary file)

4/4:
+fix the intersections, try a cube with a triangle in every location, or try a dodecahedron
+why do the missing triangles happen?
-possibly add image checkpoint at every certain number of lines
-next: move on to path tracing (do the lights)

4/11: for the paths
-Bokeh effect (wikipedia)
-Synthetic Image generation with a Lens and ... (ACM)
-A phenomological model for Bokeh Rendering
-A realistic camera model for computer graphics (1995) (Craig Kolb)
-cinematic paper in the references for Kolb

-CUDA parallelization, or run on the zoo

---------------------------------------------------------------------
/********************* Miscellaneous to do *************************/
---------------------------------------------------------------------

-Separate into src, obj, lib, and bin folders (adjust makefile)


---------------------------------------------------------------------
/*************************** LOG ***********************************/
---------------------------------------------------------------------

/********** 2/14: Makefile ******************/

+Create makefile and resolve compilation issues.
+Change to C++
+Separate out main.h from main.cpp

/********** 2/14: Scene Parsing ************/

OBJparser.py:
+Use Maya to produce edited obj files
+Update OBJparser.py to handle Maya obj files


TXTparser.py:
+Take txt file of vertex, face arrays as input
+Produce a .sce file of TRIANGLE primitives
+No material is attached to these primitives (INCLUDE needs to add material)


/********* 2/21: Scene Parsing  ******/

+Create more Maya edited obj files (bunny, dragon, teapot, mobster, etc)

SCEparser.py:
+Primitives: CAMERA, LIGHT, MATERIAL, SPHERE, TRIANGLE
+# handle comments
-INCLUDE - how to take .sce file of TRIANGLES only and add material
-Transformations, for included geometry mostly
	-Sphere and Triangle parsers need to take care of transforms
	-how to handle transforms in order? and more than one of one kind?

-Object instancing? INSTANCE 

Acceleration structure:
-kd tree adaptation

/********* 2/28: Solving .h file problem  ******/

+how to get makefile to compile

-rewrite .py with c++ parser, using regex
-Question: when adding sphere or triangle, should object array be edited?  or should intermediate scene rep for sphere and triangle contain a mat index?
Could be like tuples <sphere, matindex>

+make very simple scene of one sphere and two tris
+change Triangle struct and Sphere struct to hold a material index
+change static arrays to be vectors? cpp implementation is just an array that can dynamically grow
+render this very simple scene
+simple scene works from SCEscene class
-Parse from sce file
-regex in C : would you use PCRE?
-if it all works well, then continue building SCEparser


/********* 3/14: PARSE class  ******/

======
*Main idea is to take argList and convert it into correct parameter of correct type
ie. [200, 5, 3] -> vec3
ie. UP -> vec3
ie. "SPOT" -> lightType
etc

-void convertArgList(); //new
	void printConvertedArgList(); //new

-toVec3 Map

How to fix parsing:
Ideal: 
-YAML scene description
-python parser gives dictionary
-python parser gives binary file
-C++ opens serialized binary file and parses

What I should do:
+fix/extend python parser so that transformations are handled
-python parser gives serialized binary file
-c++ opens serialized binary file, parses, and builds scene

The format of the binary file is:
-send camera
-send light(s)
-send material(s)
-send sphere(s)
-send triangle(s)
-send END code

-each is a command followed by args
ie. CAM_CMD CAM_ARG_1 CAM_ARG_2 CAM_ARG_3 CAM_ARG_4

The parser's job is to call the correct function based on the command, and unpack the arguments as the correct types
each command is 4 bytes
each argument is spaced out every 4 bytes
-enums are represented with an int, 4 byte
-ints are 4 byte
-floats take up all 4 bytes

===================
-fixed parsing

What did I learn?
I rewrote the parser workflow three times.
The first time, the part I got write was the Python parser to convert user text into an intermediate format.  
The part I got wrong was trying to have the text converted .h file be compiled into the renderer.
The second time, the part I got write was having C++ process a file during run time.  The part I got wrong was that C++ shouldn't process unsanitized user file.
The solution was to have Python take a user file and produce a standardized, sanitized binary, that C++ could easily parse into a scene without resorting to messy hash tables for type look up.

Essentially, the unforeseen problems caused me to go through three versions of specification, which greatly confused me during the process and slowed it down.



/********* 4/4: Acceleration class  ******/
+fix the destructors (only free vectors of pointers)
+test the triangleBB 
+add acceleration (KDtree and KDnode)
+change to vector of object pointers

+dd method to udpate the Scene with the tree, and update the main.cpp to use the tree
	-intersectScene
	-isLightVisible
	-trace

	-surface
	-render

-bugs:
-missing triangles? check intersection functions
-segfault on bunny example when creating the tree - overflow stack memory?



/////


-add timing for rendering
-new splitting method for building kd-tree
-add destructor for KDtree and KDnode
-clean up SCEparser.h, functions should be defined in SCEparser.cpp
-also clean up where to put scene intersection vs. kdtree intersection
-replace reference to FLT_MAX with INFINITY macro
-clean up intersect scene functions (ie. intersectBox)
-add a low sample, high sample option to render loop, pass in as a command line arg


-add materials
-add Direct MIS, etc
-add UV mapping?






